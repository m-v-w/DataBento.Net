using System;
using System.Collections.Immutable;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;

namespace DbnSourceGenerator;

[Generator]
public class RecordStructGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.AdditionalTextsProvider
            //.Where(f => Path.GetExtension(f.Path) == ".json")
            .Collect();
        context.RegisterSourceOutput(provider, GenerateCode);
    }
    private void GenerateCode(SourceProductionContext context, ImmutableArray<AdditionalText> files)
    {
        foreach (var file in files)
        {
            var fields = JsonSerializer.Deserialize<HistoryMetadataField[]>(file.GetText()!.ToString())!;
            var recordName = Path.GetFileNameWithoutExtension(file.Path);
            var className = $"{recordName}Struct";
            // Build up the source code.
            var sb = new StringBuilder();
            sb.Append($@"// <auto-generated/>
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace DataBento.Net.Dbn.SchemaRecords;

[StructLayout(LayoutKind.Sequential, Pack = 1)]
public partial struct {className}
{{
    public RecordHeader Header;
");
            var sizeSum = 16; // RecordHeader size
            foreach (var field in fields.Skip(5))
            {
                var name = ToPascalCaseFromSnakeCase(field.Name!);
                var (typeName, size) = ConvertType(field.Type!);
                sb.AppendLine($"    public {typeName} {name};");
                sizeSum += size;
            }

            sb.AppendLine();
            sb.AppendLine($@"    internal const int StructSize = {sizeSum};
    public static ref {className} UnsafeReference(ReadOnlySpan<byte> span)
    {{
        if(span.Length != StructSize)
            throw new ArgumentException($""{className} struct data must be {{StructSize}} bytes"");
        return ref Unsafe.As<byte, {className}>(ref MemoryMarshal.GetReference(span));
    }}
}}
");
            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", sb.ToString());
        }
    }
    private (string typeName, int size) ConvertType(string type)
    {
        if (type[type.Length - 1] == ']')
        {
            var match = Regex.Match(type, "^char[(\\d+)]$");
            if (!match.Success)
                throw new NotSupportedException($"Unsupported type: {type}");
            var length = int.Parse(match.Groups[1].Value);
            return ($"Byte{length}InlineArray", length);
        }
        return type switch
        {
            "uint8_t" => ("byte", 1),
            "uint16_t" => ("ushort", 2),
            "uint32_t" => ("uint", 4),
            "uint64_t" => ("ulong", 8),
            "int8_t" => ("byte", 1),
            "int16_t" => ("short", 2),
            "int32_t" => ("int", 4),
            "int64_t" => ("long", 8),
            "char" => ("byte", 1),
            _ => throw new NotSupportedException($"Unsupported type: {type}")
        };
    }
    private static string ToPascalCaseFromSnakeCase(string snakeCaseString)
    {
        if (string.IsNullOrWhiteSpace(snakeCaseString))
        {
            return string.Empty;
        }
        var spacedString = snakeCaseString.Replace("_", " ");
        var titleCase = CultureInfo.InvariantCulture.TextInfo.ToTitleCase(spacedString.ToLower());
        return titleCase.Replace(" ", string.Empty);
    }
}
